package com.zcr.structural.composite;

/**
 * @author zcr
 * @date 2019/7/13-22:44
 *
 *组合模式(composite)
 * 使用组合模式的场景：
 * 把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象。
 *
 * 组合模式核心：
 * 抽象构件(Component)角色: 定义了叶子和容器构件的共同点
 * 叶子(Leaf)构件角色：无子节点
 * 容器(Composite)构件角色： 有容器特征，可以包含子节点
 *
 * 抽象组件
 * 叶子节点
 * 容器组件
 *
 *
 *
 * 组合模式工作流程分析：
 * 组合模式为处理树形结构提供了完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性的对待容器和叶子。
 * 当容器对象的指定方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员，并调用执行。其中，使用了递归调用的机制对整个结构进行处理。
 *
 * 使用组合模式，模拟杀毒软件架构设计
 * 文件夹怎么处理、视频软件、图片怎么处理
 *
 *
 * 开发中的应用场景：
 * 操作系统的资源管理器
 * GUI中的容器层次图
 * XML文件解析
 * OA系统中，组织结构的处理
 * Junit单元测试框架
 * 底层设计就是典型的组合模式，TestCase(叶子)、TestUnite(容器)、Test接口(抽象)
 *
 * 组合模式非常适合处理树形结构
 */
public class Client {

    public static void main(String[] args) {
        //* 组合模式 将对象组合成树状结构以表示”部分和整体“层次结构，使得客户可以统一的调用叶子对象和容器对象
        //叶子节点实现抽象组件重写杀毒方法、容器节点实现抽象组件构建列表进行增删改查并且重写递归的杀毒方法（调用叶子节点的杀毒方法）
        //处理叶子节点也好，容器节点也好，有一个统一的处理方法
        AbstractFile f1 = new Folder("我的收藏");
        AbstractFile f2 = new ImageFile("风景照.jpg");
        AbstractFile f3 = new TextFile("tst.txt");
        AbstractFile f4 = new VideoFile("珍珠.avi");


        //对这些有一个统一的方式，处理整体对象和部分对象，因为它们有着统一的接口
        f4.killVirus();
        //f1.add(f2);
        ((Folder) f1).add(f3);
        f1.killVirus();

        //也可以把一个文件夹添加到另一个文件夹中

    }
}
